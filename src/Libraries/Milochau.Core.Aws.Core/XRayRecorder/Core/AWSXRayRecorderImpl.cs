using Milochau.Core.Aws.Core.XRayRecorder.Core.Exceptions;
using Milochau.Core.Aws.Core.XRayRecorder.Core.Internal.Context;
using Milochau.Core.Aws.Core.XRayRecorder.Core.Internal.Emitters;
using Milochau.Core.Aws.Core.XRayRecorder.Core.Internal.Entities;
using Milochau.Core.Aws.Core.XRayRecorder.Core.Sampling;
using Milochau.Core.Aws.Core.XRayRecorder.Core.Sampling.Local;
using Milochau.Core.Aws.Core.XRayRecorder.Core.Strategies;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Milochau.Core.Aws.Core.XRayRecorder.Core
{
    /// <summary>
    /// This class provides utilities to build an instance of <see cref="AWSXRayRecorder"/> with different configurations.
    /// </summary>
    public abstract class AWSXRayRecorderImpl(ISegmentEmitter emitter) : IAWSXRayRecorder
    {
        protected const long MaxSubsegmentSize = 100;

        /// <summary>
        /// Gets or sets the sampling strategy.
        /// </summary>
        public LocalizedSamplingStrategy SamplingStrategy { get; set; } = new LocalizedSamplingStrategy();

        /// <summary>
        /// Instance of <see cref="ITraceContext"/>, used to store segment/subsegment.
        /// </summary>
        public ITraceContext TraceContext { get; set; } = DefaultTraceContext.GetTraceContext();

        /// <summary>
        /// Gets the runtime context which is generated by plugins.
        /// </summary>
        public IDictionary<string, object>? RuntimeContext { get; protected set; }

        /// <summary>
        /// Emitter used to send Traces.
        /// </summary>
        public ISegmentEmitter Emitter { get; set; } = emitter;

        protected bool Disposed { get; set; }

        protected Dictionary<string, object> ServiceContext { get; set; } = [];

        /// <summary>
        /// Defines exception serialization stategy to process recorded exceptions. <see cref="Strategies.ExceptionSerializationStrategy"/>
        /// </summary>
        public DefaultExceptionSerializationStrategy ExceptionSerializationStrategy { get; set; } = new DefaultExceptionSerializationStrategy();

        /// <summary>
        /// Instance of <see cref="DefaultStreamingStrategy"/>, used to define the streaming strategy for segment/subsegment.
        /// </summary>
        public DefaultStreamingStrategy StreamingStrategy { get; set; } = new DefaultStreamingStrategy();

        /// <summary>
        /// Begin a tracing subsegment. A new subsegment will be created and added as a subsegment to previous segment.
        /// </summary>
        /// <param name="name">Name of the operation.</param>
        /// <param name="timestamp">Sets the start time of the subsegment</param>
        /// <exception cref="ArgumentNullException">The argument has a null value.</exception>
        /// <exception cref="EntityNotAvailableException">Entity is not available in trace context.</exception>
        public abstract void BeginSubsegment(string name, DateTime? timestamp = null);

        /// <summary>
        /// Begin a tracing subsegment. A new subsegment will be created and added as a subsegment to previous segment.
        /// </summary>
        /// <param name="name">Name of the operation.</param>
        public void BeginSubsegmentWithoutSampling(string name)
        {
            BeginSubsegment(name);
            TraceContext.GetEntity().Sampled = SampleDecision.NotSampled;
        }

        /// <summary>
        /// End a subsegment.
        /// </summary>
        /// <param name="timestamp">Sets the end time for the subsegment</param>
        public abstract void EndSubsegment();

        /// <summary>
        /// Adds the specified key and value as annotation to current segment.
        /// The type of value is restricted. Only <see cref="string" />, <see cref="int" />, <see cref="long" />,
        /// <see cref="double" /> and <see cref="bool" /> are supported.
        /// </summary>
        /// <param name="key">The key of the annotation to add.</param>
        /// <param name="value">The value of the annotation to add.</param>
        /// <exception cref="EntityNotAvailableException">Entity is not available in trace context.</exception>
        public void AddAnnotation(string key, object value)
        {
            try
            {
                TraceContext.GetEntity().AddAnnotation(key, value);
            }
            catch (EntityNotAvailableException)
            {
            }
        }

        /// <summary>
        /// Set namespace to current segment.
        /// </summary>
        /// <param name="value">The value of the namespace.</param>
        /// <exception cref="System.ArgumentException">Value cannot be null or empty.</exception>
        public void SetNamespace(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                throw new ArgumentException("Value cannot be null or empty.", nameof(value));
            }

            try
            {
                if (TraceContext.GetEntity() is not Subsegment subsegment)
                {
                    return;
                }

                subsegment.Namespace = value;
            }
            catch (EntityNotAvailableException)
            {
            }
        }

        /*
        /// <summary>
        /// Populates runtime and service contexts for the segment.
        /// </summary>
        /// <param name="newSegment">Instance of <see cref="Segment"/>.</param>
        protected void PopulateNewSegmentAttributes(Segment newSegment)
        {
            if (RuntimeContext != null)
            {
                foreach (var keyValuePair in RuntimeContext)
                {
                    newSegment.Aws[keyValuePair.Key] = keyValuePair.Value;
                }
            }

            foreach (var keyValuePair in ServiceContext)
            {
                newSegment.Service[keyValuePair.Key] = keyValuePair.Value;
            }
        }
        */

        /// <summary>
        /// Adds the specified key and value as http information to current segment.
        /// </summary>
        /// <param name="key">The key of the http information to add.</param>
        /// <param name="value">The value of the http information to add.</param>
        /// <exception cref="ArgumentException">Key is null or empty.</exception>
        /// <exception cref="ArgumentNullException">Value is null.</exception>
        /// <exception cref="EntityNotAvailableException">Entity is not available in trace context.</exception>
        public void AddHttpInformation(string key, object value)
        {
            if (string.IsNullOrEmpty(key))
            {
                throw new ArgumentException("Key cannot be null or empty", nameof(key));
            }

            ArgumentNullException.ThrowIfNull(value);

            try
            {
                TraceContext.GetEntity().Http[key] = value;
            }
            catch (EntityNotAvailableException)
            {
            }
        }

        /// <summary>
        /// Mark the current segment as fault.
        /// </summary>
        /// <exception cref="EntityNotAvailableException">Entity is not available in trace context.</exception>
        public void MarkFault()
        {
            try
            {
                Entity entity = TraceContext.GetEntity();
                entity.HasFault = true;
                entity.HasError = false;
            }
            catch (EntityNotAvailableException)
            {
            }
        }

        /// <summary>
        /// Mark the current segment as error.
        /// </summary>
        /// <exception cref="EntityNotAvailableException">Entity is not available in trace context.</exception>
        public void MarkError()
        {
            try
            {
                Entity entity = TraceContext.GetEntity();
                entity.HasError = true;
                entity.HasFault = false;
            }
            catch (EntityNotAvailableException)
            {
            }
        }

        /// <summary>
        /// Add the exception to current segment and also mark current segment as fault.
        /// </summary>
        /// <param name="ex">The exception to be added.</param>
        /// <exception cref="EntityNotAvailableException">Entity is not available in trace context.</exception>
        public void AddException(Exception ex)
        {
            try
            {
                TraceContext.GetEntity().AddException(ex);
            }
            catch (EntityNotAvailableException)
            {
            }
        }

        /// <summary>
        /// Mark the current segment as being throttled. And Error will also be marked for current segment.
        /// </summary>
        /// <exception cref="EntityNotAvailableException">Entity is not available in trace context.</exception>
        public void MarkThrottle()
        {
            try
            {
                TraceContext.GetEntity().IsThrottled = true;
                MarkError();
            }
            catch (EntityNotAvailableException)
            {
            }
        }

        /// <summary>
        /// Adds the specified key and value to metadata under default namespace.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="value">The value.</param>
        public void AddMetadata(string key, object value)
        {
            try
            {
                TraceContext.GetEntity().AddMetadata(key, value);
            }
            catch (EntityNotAvailableException)
            {
            }
        }

        /// <summary>
        /// Adds the specified key and value to metadata with given namespace.
        /// </summary>
        /// <param name="nameSpace">The namespace.</param>
        /// <param name="key">The key.</param>
        /// <param name="value">The value.</param>
        public void AddMetadata(string nameSpace, string key, object value)
        {
            try
            {
                TraceContext.GetEntity().AddMetadata(nameSpace, key, value);
            }
            catch (EntityNotAvailableException)
            {
            }
        }

        /// <summary>
        /// Free resources within the object.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Free resources within the object.
        /// </summary>
        /// <param name="disposing">To dispose or not.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (Disposed)
            {
                return;
            }

            if (disposing)
            {
                Emitter?.Dispose();
                Disposed = true;
            }
        }

        /// <summary>
        /// Returns subsegments.
        /// </summary>
        /// <param name="entity">Instance of <see cref="Entity"/></param>
        /// <returns>Subsegments of instance of <see cref="Entity"/>.</returns>
        protected Subsegment[] GetSubsegmentsToStream(Entity entity)
        {
            Subsegment[] copy;
            lock (entity.Subsegments)
            {
                copy = new Subsegment[entity.Subsegments.Count];
                entity.Subsegments.CopyTo(copy);
            }

            return copy;
        }

        /// <summary>
        /// Populates runtime and service contexts.
        /// </summary>
        protected void PopulateContexts()
        {
            RuntimeContext = new Dictionary<string, object>();

            // Prepare XRay section for runtime context
            var xrayContext = new ConcurrentDictionary<string, string>();

            xrayContext["sdk"] = "X-Ray for .NET Core";
            xrayContext["sdk_version"] = "Unknown";

            RuntimeContext["xray"] = xrayContext;
            ServiceContext["runtime"] = ".NET Core Framework";
            ServiceContext["runtime_version"] = Environment.Version.ToString();
        }

        /// <summary>
        /// If sampled and is emittable sends segments using emitter else checks for subsegments to stream.
        /// </summary>
        /// <param name="segment"></param>
        protected void ProcessEndSegment(Segment segment)
        {
            PrepEndSegment(segment);

            if (segment.Sampled == SampleDecision.Sampled && segment.IsEmittable())
            {
                Emitter.Send(segment);
            }
            else if (StreamingStrategy.ShouldStream(segment))
            {
                StreamingStrategy.Stream(segment, Emitter);
            }
        }

        /// <summary>
        /// Sets segment IsInProgress to false and releases the segment.
        /// </summary>
        /// <param name="segment">Instance of <see cref="Segment"/>.</param>
        protected void PrepEndSegment(Segment segment)
        {
            segment.IsInProgress = false;
            segment.Release();
        }

        /// <summary>
        /// Sends root segment of the current subsegment.
        /// </summary>
        protected void ProcessEndSubsegment(DateTime? timestamp = null)
        {
            var subsegment = PrepEndSubsegment();

            if (subsegment == null)
            {
                return;
            }

            if (timestamp == null)
            {
                subsegment.SetEndTimeToNow();
            }
            else
            {
                subsegment.SetEndTime(timestamp.Value);
            }

            // Check emittable
            if (subsegment.RootSegment != null && subsegment.IsEmittable())
            {
                // Emit
                Emitter.Send(subsegment.RootSegment);
            }
            else if (subsegment.RootSegment != null && StreamingStrategy.ShouldStream(subsegment))
            {
                StreamingStrategy.Stream(subsegment.RootSegment, Emitter);
            }
        }

        private Subsegment? PrepEndSubsegment()
        {
            // If the request is not sampled, a segment will still be available in TraceContext.
            Entity entity = TraceContext.GetEntity();

            // If the segment is not sampled, a subsegment is not created. Do nothing and exit.
            if (entity.Sampled != SampleDecision.Sampled)
            {
                return null;
            }

            Subsegment subsegment = (Subsegment)entity;

            subsegment.IsInProgress = false;

            // Restore parent segment to trace context
            if (subsegment.Parent != null)
            {
                TraceContext.SetEntity(subsegment.Parent);
            }

            // Drop ref count
            subsegment.Release();

            return subsegment;
        }

        /// <summary>
        /// Trace a given function with return value. A subsegment will be created for this method.
        /// Any exception thrown by the method will be captured.
        /// </summary>
        /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
        /// <param name="name">The name of the trace subsegment for the method.</param>
        /// <param name="method">The method to be traced.</param>
        /// <returns>The return value of the given method.</returns>
        public TResult TraceMethod<TResult>(string name, Func<TResult> method)
        {
            BeginSubsegment(name);

            try
            {
                return method();
            }
            catch (Exception e)
            {
                AddException(e);
                throw;
            }

            finally
            {
                EndSubsegment();
            }
        }

        /// <summary>
        /// Trace a given method returns void.  A subsegment will be created for this method.
        /// Any exception thrown by the method will be captured.
        /// </summary>
        /// <param name="name">The name of the trace subsegment for the method.</param>
        /// <param name="method">The method to be traced.</param>
        public void TraceMethod(string name, Action method)
        {
            BeginSubsegment(name);

            try
            {
                method();
            }
            catch (Exception e)
            {
                AddException(e);
                throw;
            }

            finally
            {
                EndSubsegment();
            }
        }

        /// <summary>
        /// Trace a given asynchronous function with return value. A subsegment will be created for this method.
        /// Any exception thrown by the method will be captured.
        /// </summary>
        /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates</typeparam>
        /// <param name="name">The name of the trace subsegment for the method</param>
        /// <param name="method">The method to be traced</param>
        /// <returns>The return value of the given method</returns>
        public async Task<TResult> TraceMethodAsync<TResult>(string name, Func<Task<TResult>> method)
        {
            BeginSubsegment(name);

            try
            {
                return await method();
            }
            catch (Exception e)
            {
                AddException(e);
                throw;
            }

            finally
            {
                EndSubsegment();
            }
        }

        /// <summary>
        /// Trace a given asynchronous method that returns no value.  A subsegment will be created for this method.
        /// Any exception thrown by the method will be captured.
        /// </summary>
        /// <param name="name">The name of the trace subsegment for the method</param>
        /// <param name="method">The method to be traced</param>
        public async Task TraceMethodAsync(string name, Func<Task> method)
        {
            BeginSubsegment(name);

            try
            {
                await method();
            }
            catch (Exception e)
            {
                AddException(e);
                throw;
            }

            finally
            {
                EndSubsegment();
            }
        }

        /// <summary>
        /// Gets entity (segment/subsegment) from the <see cref="TraceContext"/>.
        /// </summary>
        /// <returns>The entity (segment/subsegment)</returns>
        /// <exception cref="EntityNotAvailableException">Thrown when the entity is not available to get.</exception>
        public Entity GetEntity()
        {
            return TraceContext.GetEntity();
        }

        /// <summary>
        /// Set the specified entity (segment/subsegment) into <see cref="TraceContext"/>.
        /// </summary>
        /// <param name="entity">The entity to be set</param>
        /// <exception cref="EntityNotAvailableException">Thrown when the entity is not available to set</exception>
        public void SetEntity(Entity entity)
        {
            TraceContext.SetEntity(entity);
        }

        /// <summary>
        /// Checks whether entity is present in <see cref="TraceContext"/>.
        /// </summary>
        /// <returns>True if entity is present TraceContext else false.</returns>
        public bool IsEntityPresent()
        {
            return TraceContext.IsEntityPresent();
        }

        /// <summary>
        /// Clear entity from <see cref="TraceContext"/>.
        /// </summary>
        public void ClearEntity()
        {
            TraceContext.ClearEntity();
        }

        /// <summary>
        /// Configures recorder with <see cref="Strategies.ExceptionSerializationStrategy"/>.  While setting number consider max trace size
        /// limit : https://aws.amazon.com/xray/pricing/
        /// </summary>
        /// <param name="exceptionSerializationStartegy">An instance of <see cref="ExceptionSerializationStrategy"/></param>
        public void SetExceptionSerializationStrategy(DefaultExceptionSerializationStrategy exceptionSerializationStartegy)
        {
            ExceptionSerializationStrategy = exceptionSerializationStartegy;
        }
    }
}
